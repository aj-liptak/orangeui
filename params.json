{"tagline":"OrangeUI Web Framework 0.1","body":"# Commons\r\n\r\nThe Commons module is a base set of tools to help improve the structure of your application. It provides you with:\r\n\r\n* Object-oriented javascript objects\r\n* Event mixin for objects\r\n* HTML5 wrapper functions\r\n* Module dependency management\r\n\r\n## Documentation\r\n\r\n### Class\r\n\r\n* [extend()](#class-extend)\r\n* [include()](#class-include)\r\n* [proxy()](#class-proxy)\r\n\r\n### Events\r\n\r\n* [on()](#events-on)\r\n* [once()](#events-once)\r\n* [fire()](#events-fire)\r\n* [detach()](#events-detach)\r\n\r\n### EventHandle\r\n\r\n* [detach()](#event-handle-detach)\r\n\r\n### EventTarget\r\n\r\n* [currentTarget](#event-target-current-target)\r\n* [target](#event-target-target)\r\n* [stopPropagation()](#event-target-stop-propagation)\r\n\r\n### Modules\r\n\r\n* [add()](#modules-add)\r\n* [use()](#modules-use)\r\n* [include()](#modules-include)\r\n* [exports](#modules-exports)\r\n\r\n### Cache\r\n\r\n* [init()](#cache-init)\r\n* [updateNetworkStatus()](#cache-update-network-status)\r\n* [isActive()](#cache-is-active)\r\n\r\n**includes the Events mixin*\r\n\r\n### Storage\r\n\r\n* [get()](#storage-get)\r\n* [set()](#storage-set)\r\n* [remove()](#storage-remove)\r\n* [flush()](#storage-flush)\r\n* [flushExpired()](#storage-flush-expired)\r\n* [isSupported()](#storage-is-supported)\r\n\r\n### Location\r\n\r\n* [getLocation()](#location-get-location)\r\n\r\n## Class\r\n\r\nOrangeUI provides basic OOP tools via the **Class** object, which can be used to create and extend classes, include mixins, and proxy functions.\r\n\r\n<a name=\"class-extend\" />\r\n### extend(object)\r\n\r\nClass method `extend()` can be used to create new classes and subclass existing classes. Each base class definition expects an initialize() method. Calling `this._super()` in an instance method will access and execute the superclass' method.\r\n\r\n**Arguments**\r\n\r\n* object - the javascript object representing the class instance methods. The object must implement the method initialize() as its constructor if it is not inheriting from another class.\r\n\r\n**Example**\r\n\r\n```js\r\n// creates a new class 'MyClass'\r\nvar MyClass = Class.extend({\r\n\r\n\tinitialize: function() {\r\n\t\tconsole.log('Hello World');\r\n\t},\r\n\r\n\tgetAge: function() {\r\n\t\treturn 25;\r\n\t}\r\n\r\n});\r\n\r\n// creates a subclass of 'MyClass'\r\nvar MySubClass = MyClass.extend({\r\n\r\n\tgetMyAge: function() {\r\n\t\treturn 'My age is ' + this.getAge();\r\n\t}\r\n\r\n});\r\n```\r\n\r\n```js\r\n// accessing the superclass\r\nvar MySubClass = MyClass.extend({\r\n\t\r\n\tgetAge: function() {\r\n\t\treturn this._super() + 5; // returns 30\r\n\t}\r\n\r\n});\r\n```\r\n\r\n---------------------------------------\r\n\r\n<a name=\"class-include\" />\r\n### include(mixin)\r\n\r\nBinds a mixin of functions to an existing class so that all mixin methods are available to instances of that class.\r\n\r\n**Arguments**\r\n\r\n* mixin - the object containing the functions to add to the given class\r\n\r\n**Example**\r\n\r\n```js\r\nvar MyClass = Class.extend({\r\n\t\r\n\tinitialize: function() {\r\n\t\tconsole.log('Hello World');\r\n\t}\r\n\r\n});\r\n\r\nvar MyMixin = {\r\n\tmyMethodOne: function() {\r\n\t\treturn 'one';\r\n\t},\r\n\tmyMethodTwo: function() {\r\n\t\treturn 'two';\r\n\t}\r\n};\r\n\r\nMyClass.include(MyMixin);\r\n\r\nvar instance = new MyClass();\r\ninstance.myMethodTwo(); // will return 'two'\r\n```\r\n\r\n---------------------------------------\r\n\r\n<a name=\"class-proxy\" />\r\n### proxy(function, context)\r\n\r\nReturns a function bound to a given context object for execution at a later time. This provides the same functionality as jQuery's `$.proxy()` function.\r\n\r\n**Arguments**\r\n\r\n* function - the function to bind the context to\r\n* context - the object to use as the context\r\n\r\n**Example**\r\n\r\n```js\r\n// proxies a function with a context object\r\nClass.proxy(function() {\r\n\tconsole.log(this.name); // prints 'my-context'\r\n}, { name: 'my-context' });\r\n```\r\n\r\n\r\n## Events\r\n\r\nOrangeUI provides the *Event* mixin that can be used to bind events to objects. Objects including this mixin have access to the `once()`, `on()`, `fire()`, and `detach()` methods to handle all event listening on an object. An optional parent can be passed to the mixin to allow for event bubbling up a heirarchy you define.\r\n\r\nThe `on()` function will return an event handle that can be used to detach the event at a later time. Callbacks receive an `e` argument and a `data` argument when executed, the `e` argument including the target, currentTarget, and access to call `e.stopPropagation` to prevent event bubbling. The `data` argument is set to the optional second argument passed to the `fire()` method to trigger an event.\r\n\r\n<a name=\"events-on\" />\r\n### on(event, callback, context)\r\n\r\nSubscribes a callback to a given event and returns an **EventHandle** instance for later detaching.\r\n\r\n**Arguments**\r\n\r\n* event -\ta string of the event to listen for \r\n* callback - a function to execute when the event is fired \r\n* context - an optional context to proxy the callback with \r\n\r\n**Examples**\r\n\r\n```js\r\n// bind an 'load' event\r\nmyEventedClass.on('load', function(e, data) {\r\n\tconsole.log('Loaded!');\r\n});\r\n\r\n```js\r\n// or with an optional context\r\n\r\nvar context = {\r\n\tmsg: \"Appeared!\"\r\n};\r\n\r\nmyEventedClass.on('appear', function(e, data) {\r\n\tconsole.log(this.msg); // prints 'Appeared!'\r\n}, context);\r\n```\r\n\r\n---------------------------------------\r\n\r\n<a name=\"events-once\" />\r\n### once(event, callback, context)\r\n\r\nSubscribes a callback to an event just once. Once the event is fired, all callbacks defined using `once()` will be detached.\r\n\r\n**Arguments**\r\n\r\n* event - a string of the event to listen for \r\n* callback - a function to execute when the event is fired \r\n* context - an optional context to proxy the callback with \r\n\r\n**Examples**\r\n\r\n```js\r\n// bind once event\r\nmyEventedClass.once('appear', function(e, data) {\r\n\tconsole.log('Firing');\r\n});\r\n\r\nmyEventedClass.fire('appear'); // prints 'Firing'\r\nmyEventedClass.fire('appear'); // prints nothing\r\n\r\n```\r\n\r\n---------------------------------------\r\n\r\n<a name=\"events-fire\" />\r\n### fire(event, [data])\r\n\r\nFires an event of a given name and passes an optional payload to all subscribing callbacks.\r\n\r\n**Arguments**\r\n\r\n* event - a string of the event to fire \r\n* data - a payload to pass to all registered callbacks \r\n\r\n**Examples**\r\n\r\n```js\r\n// bind once event\r\nmyEventedClass.on('load', function(e) {\r\n\tconsole.log('Loaded!');\r\n});\r\n\r\nmyEventedClass.fire('appear'); // prints 'Loaded!'\r\n```\r\n\r\n```js\r\n// bind once event\r\nmyEventedClass.on('appear', function(e, data) {\r\n\tconsole.log(data);\r\n});\r\n\r\n// prints { msg: 'hello' }\r\nmyEventedClass.fire('appear', { msg: 'hello'});\r\n```\r\n\r\n---------------------------------------\r\n\r\n<a name=\"events-detach\" />\r\n### detach([event], [callback])\r\n\r\nDetaches listeners from a given object. It will detach all listeners for an event when a callback is not set, and all listeners on that object when no arguments are passed.\r\n\r\n**Arguments**\r\n\r\n* event -\tthe event string to unbind listeners for \r\n* callback - the callback to unbind from an given event \r\n\r\n**Examples**\r\n\r\n```js\r\n// unbinds a specific listener\r\nvar onLoad = function(e) {\r\n\tconsole.log('Loaded!');\r\n};\r\n\r\n// bind the event\r\nmyEventedClass.on('load', onLoad);\r\n\r\n// detach that event\r\nmyEventedClass.detach('load', onLoad);\r\n```\r\n\r\n```js\r\n// unbinds all listeners for 'load'\r\nmyEventedClass.detach('load');\r\n```\r\n\r\n```js\r\n// unbinds all listeners\r\nmyEventedClass.detach();\r\n```\r\n\r\n## EventHandle\r\n\r\n<a name=\"event-handle-detach\" />\r\n### detach()\r\n\r\nDetaches the listener bound to the given EventHandle\r\n\r\n**Examples**\r\n\r\n```js\r\nvar handle = myEventedClass.on('load', function(e) {\r\n\tconsole.log('Loaded!');\r\n});\r\n\r\nhandle.detach(); // detaches the event\r\n```\r\n\r\n## EventTarget\r\n\r\nThe EventTarget is passed as the `e` argument to all callback functions when an event is fired. If a class has defined its `_parent` reference, the EventTarget will attempt to bubble events up the hierachy until it either reaches a parent of `null` or `stopPropagation()` is called.\r\n\r\n<a name=\"event-target-current-target\" />\r\n### currentTarget\r\n\r\nReturns the current object the event is firing on.\r\n\r\n---------------------------------------\r\n\r\n<a name=\"event-target-target\" />\r\n### target\r\n\r\nReturns the object the event was originally triggered on.\r\n\r\n---------------------------------------\r\n\r\n<a name=\"event-target-stop-propagation\" />\r\n### stopPropagation()\r\n\r\nStops the bubbling of an event up the parent hierarchy when called inside a callback.\r\n\r\n**Examples**\r\n\r\n```js\r\nmyEventedClassParent.on('load', function(e) {\r\n\tconsole.log('Loaded Parent!');\r\n});\r\n\r\nmyEventedClass._parent = myEventedClassParent;\r\n\r\nmyEventedClass.on('load', function(e) {\r\n\te.stopPropagation();\r\n\tconsole.log('Loaded!');\r\n});\r\n\r\nmyEventedClassChild._parent = myEventedClass;\r\n\r\nmyEventedClassChild.on('load', function(e) {\r\n\tconsole.log('Loaded Child!');\r\n});\r\n\r\nmyEventedClassChild.fire('load');\r\n\r\n// prints 'Loaded Child!'\r\n// prints 'Loaded!'\r\n// doesn't print 'Loaded Parent!'\r\n```\r\n\r\n## Modules\r\n\r\nModules give an easy way to manage dependencies and organize logically separate code components. Since client-side code is executed as it is included in your HTML files, modules are registered via the `add()` function on the global object. This method specifics the code to add as well as the modules it is dependent on, and the version of the module.\r\n\r\n<a name=\"modules-add\" />\r\n### add(module, fn, dep, version)\r\n\r\nAdds a module with a given name and associates it with a given number of dependencies and versions. The `add()` method is available globally on the `Orange` object.\r\n\r\n**Arguments**\r\n\r\n* module - the module string name \r\n* fn - the function containing the modules code \r\n* dep -\tan array of module dependency name strings \r\n* version -\tthe string version number of the module \r\n\r\n**Examples**\r\n\r\n```js\r\nOrange.add('my-module', function() {\r\n\t\t\r\n\t// my code here\r\n\r\n}, ['my-other-module'], '0.1');\r\n```\r\n\r\n---------------------------------------\r\n\r\n<a name=\"modules-use\" />\r\n### use(dependencies…, fn)\r\n\r\nOn occasion, it might be necessary to run adhoc code without necessarily creating a module. This can be done using the `use()` method, which loads required dependencies for the code. The code within the function will be run immediately when `use()` is executed. The `use()` method is available globally on the `Orange` object.\r\n\r\n**Arguments**\r\n\r\n* dependencies - (multiple) the string names of the modules \r\n* fn - a function containing the adhoc code \r\n\r\n**Examples**\r\n\r\n```js\r\nOrange.use('my-module-one', 'my-module-two', function() {\r\n\t\t\r\n\t// code goes here\r\n\r\n});\r\n```\r\n\r\n---------------------------------------\r\n\r\n<a name=\"modules-include\" />\r\n### include(module)\r\n\r\n To load required components, OrangeUI uses a convention similar to that seen in NodeJS. Requires and loads an external module and returns the object associated with that module's `exports` object. The `include()` method is available in the global scope.\r\n\r\n**Arguments**\r\n\r\n* module - the name of the module to import\r\n\r\n**Examples**\r\n\r\n```js\r\n// returns the exports object of module myClass\r\nvar myClass = include('myClass');\r\n```\r\n\r\n---------------------------------------\r\n\r\n<a name=\"modules-exports\" />\r\n### exports\r\n\r\nTo export private code components, the exports object is passed to the function. It can either be set in its entirety, or have attributes added to it.\r\n\r\n**Examples**\r\n\r\n```js\r\nOrange.add('my-module', function(exports) {\r\n\t\t\r\n\tvar myClass = include('myClass');\r\n\r\n\tvar newClass = myClass.extend({\r\n\t\tgetName: function() {\r\n\t\t\treturn 'newClass';\r\n\t\t}\r\n\t});\r\n\t\t\r\n\texports.newClass = newClass; // the class is an attribute\r\n\r\n\texports = newClass; // the class is the entire object\r\n\r\n}, ['my-other-module'], '0.1');\r\n```\r\n\r\n## Cache - HTML5 Offline Mode\r\n\r\nCommons provides built in support for HTML5's offline mode caching and online/offline javascript events. In conjunction with a **cache.manifest** file for your web application resources, it is possible to create a fully functional offline web application in the browser.\r\n\r\nOffline caching can be accessed through the **Cache** object, which supports `updateNetworkStatus()` method for checking the current connection and fires the custom online/offline event **statusChange** with a boolean payload for if the connection is online. You can also bind events on to the Cache object to listen for status changes.\r\n\r\n<a name=\"cache-init\" />\r\n### init()\r\n\r\nInitializes the Cache and starts listening for online or offline events. \r\n\r\n**Examples**\r\n\r\n```js\r\nCache.init();\r\n```\r\n\r\n<a name=\"cache-update-network-status\" />\r\n### updateNetworkStatus()\r\n\r\nRequests a manual update of the current status of the web application's network connection. Supported browsers will fire `statusChange` events when the browser goes online/offline, and fall back to polling if the navigator.onLine property is not available.\r\n\r\n**Examples**\r\n\r\n```js\r\nCache.updateNetworkStatus(); // will fire 'statusChange' event\r\n```\r\n\r\n<a name=\"cache-is-active\" />\r\n### isActive()\r\n\r\nReturns a boolean value stating whether the Cache has been initialized.\r\n\r\n```js\r\nvar active = Cache.isActive();\r\nconsole.log(active); // prints true or false\r\n```\r\n\r\n## Storage - HTML5 Local Storage\r\n\r\nThe **Commons** module provides a wrapper for the HTML5 localStorage feature, adding support for the serializing of Javascript objects and setting autoexpirable keys. The **Storage** object supports `get()`, `set()`, `remove()`, `flush()`, and `flushExpired()`.\r\n\r\n<a name=\"storage-get\" />\r\n### get(key, [defaultValue])\r\n\r\nReturns the value for a key from localStorage.\r\n\r\n**Arguments**\r\n\r\n* key - a key to lookup from the local storage object  \r\n* defaultValue - the default value to return when the key is not found  \r\n\r\n**Examples**\r\n\r\n```js\r\nvar myKey = Storage.get('myKey');\r\n```\r\n\r\n---------------------------\r\n\r\n<a name=\"storage-set\" />\r\n### set(key, value, [ttl])\r\n\r\nSets an object value to localStorage for a given key.\r\n\r\n**Arguments**\r\n\r\n* key - a key store the local storage object to  \r\n* value - the value to store for the given key  \r\n* ttl - optional how long before the object should be auto flushed in milliseconds\r\n\r\n**Examples**\r\n\r\n```js\r\n// store a string\r\nStorage.set('myKey', 'myValue');\r\n\r\n// or an object\r\nStorage.set('myKey', { value: 'myValue' });\r\n```\r\n\r\n---------------------------\r\n\r\n<a name=\"storage-remove\" />\r\n### remove(key)\r\n\r\nRemoves an object from localStorage for a given key.\r\n\r\n**Arguments**\r\n\r\n* key - a key to remove from localStorage\r\n\r\n**Examples**\r\n\r\n```js\r\nStorage.remove('myKey');\r\n```\r\n\r\n---------------------------\r\n\r\n<a name=\"storage-flush\" />\r\n### flush(force)\r\n\r\nFlushes all object from the localStorage object. Objects will not be flushed in offlineMode unless force is set to `true`.\r\n\r\n**Arguments**\r\n\r\n* force - whether to force clearing in offline mode\r\n\r\n**Examples**\r\n\r\n```js\r\nStorage.flush();\r\n```\r\n\r\n---------------------------\r\n\r\n<a name=\"storage-flush-expired\" />\r\n### flushExpired(force)\r\n\r\nFlushes all expired objects from the localStorage object. Objects will not be flushed in offlineMode unless force is set to `true`.\r\n\r\n**Arguments**\r\n\r\n* force -  whether to force clearing in offline mode \r\n\r\n**Examples**\r\n\r\n```js\r\nStorage.flushExpired();\r\n```\r\n\r\n<a name=\"storage-is-supported\" />\r\n### isSupported()\r\n\r\nReturns a boolean value checking if the localStorage cache is supported.\r\n\r\n**Examples**\r\n\r\n```js\r\nvar support = Storage.isSupported();\r\nconsole.log(support); // prints true or false\r\n```\r\n\r\n## Location - HTML5 Geolocation\r\n\r\nCommons provides a wrapper for **HTML5 Geolocation** fetching of the current location from the user's browser. The **Location** object supports the `getLocation()` method, which accepts a success and failure callback. The location is fetched asynchronously.\r\n\r\n<a name=\"location-get-location\" />\r\n### getLocation(success, failure)\r\n\r\nSubmits an asynchronous request for the location of the user's browser. The success callback will receive the coordinates object returned as its argument.\r\n\r\n**Arguments**\r\n\r\n* success(coords) - the callback that the location coordinates will be passed to.\r\n* failure(err) - the callback that will be called if the coordinates cannot be retreived\r\n\r\n**Examples**\r\n\r\n```js\r\nLocation.getLocation(function(coords) {\r\n\t\t\r\n\talert(coords); // success\r\n\t\t\r\n}, function(err) {\r\n\t\r\n\talert('Location error', err); // failure\r\n\t\r\n});\r\n```","google":"UA-31258532-1","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Orangeui"}